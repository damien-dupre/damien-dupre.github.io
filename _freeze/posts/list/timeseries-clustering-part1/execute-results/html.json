{
  "hash": "ad82e4a337b14f0a70d6f0dd13f929fd",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Time series Clustering with Dynamic Time Warping\"\n\nexecute: \n  eval: true\n  warning: false\n---\n\nIf you want to cluster time series in R, you're in luck. There are many available solutions, and the web is packed with helpful tutorials like those from [Thomas Girke](http://girke.bioinformatics.ucr.edu/GEN242/pages/mydoc/Rclustering.html), [Rafael Irizarry and Michael Love](http://genomicsclass.github.io/book/pages/clustering_and_heatmaps.html), [Andrew B. Collier](https://datawookie.netlify.com/blog/2017/04/clustering-time-series-data/), [Peter Laurinec](https://petolau.github.io/TSrepr-clustering-time-series-representations/), [Dylan Glotzer](http://www.stat.unc.edu/faculty/pipiras/timeseries/Multivariate_6_-_Classification_Clustering_-_Menu.html), and [Ana Rita Marques](http://rstudio-pubs-static.s3.amazonaws.com/398402_abe1a0343a4e4e03977de8f3791e96bb.html).\n\nDynamic Time Warping (DTW) is one of the most popular solutions. Its primary strength is that it can group time series by shape, even when their patterns are out of sync or lagged.\n\nFrom what I've seen, {TSclust} by [Pablo Montero Manso and Jos√© Antonio Vilar](https://cran.r-project.org/web/packages/TSclust/index.html) and {dtwclust} by [Alexis Sarda-Espinosa](https://cran.r-project.org/web/packages/dtwclust/index.html) are the two go-to packages for this task. They're both simple and powerful, but understanding how they work on real data can be tricky. To demystify the process, I'll simulate two distinct groups of time series and see if DTW clustering can tell them apart.\n\n### List of packages needed\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr) # data wrangling\nlibrary(ggplot2) # grammar of graphics\nlibrary(gridExtra) # merge plots\nlibrary(ggdendro) # dendrograms\nlibrary(gplots) # heatmap\nlibrary(tseries) # bootstrap\nlibrary(TSclust) # cluster time series\nlibrary(dtwclust) # cluster time series with dynamic time warping\n```\n:::\n\n\n### Data simulation\n\nLet's simulate marathon data for two types of runners. The first represents a 'classic' run where the pace steadily increases. The second represents a runner 'hitting the wall,' which we'll model as a sudden jump in pace (a significant slowdown) during the race's second half. While real data is always preferable, simulating these patterns is a great way to test our clustering method's effectiveness.\n\nWe can create a basic simulation using a `sine()` function with some added random noise for realism.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# classic run\nnoise <- runif(420) # random noise\nx <- seq(1, 420) # 42km with a measure every 100m\npace_min <- 5 # min/km (corresponds to fast run)\n\nts_sim_classic_run <- (sin(x / 10) + x / 100 + noise + pace_min) %>%\n  as.ts(.)\n\nts.plot(ts_sim_classic_run, xlab = \"Distance [x100m]\", ylab = \"Differential pace [min/km]\", main = \"Example of classic run\", ylim = c(0, 25))\n\n# wall run\nnoise <- runif(210) # random noise\nx <- seq(1, 210) # 21km with a measure every 100m\npace_min <- 5 # min/km (corresponds to fast run)\npace_wall <- 20 # min/km (corresponds to very slow run)\nts_sim_part1 <- sin(x / 5) + x / 50 + noise + pace_min\nts_sim_part2 <- sin(x / 5) + noise + pace_wall\n\nts_sim_wall_run <- c(ts_sim_part1, ts_sim_part2) %>%\n  as.ts(.)\n\nts.plot(ts_sim_wall_run, xlab = \"Distance [x100m]\", ylab = \"Differential pace [min/km]\", main = \"Example of wall run\", ylim = c(0, 25))\n```\n\n::: {.cell-output-display}\n![](timeseries-clustering-part1_files/figure-html/unnamed-chunk-2-1.png){width=384}\n:::\n\n::: {.cell-output-display}\n![](timeseries-clustering-part1_files/figure-html/unnamed-chunk-2-2.png){width=384}\n:::\n:::\n\n\nFor a more sophisticated simulation, we can use an ARIMA model, specifically its autoregressive (AR) component.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npace_min <- 5 # min/km (corresponds to fast run)\npace_wall <- 20 # min/km (corresponds to very slow run)\n\n# classic run\nts_sim_classic_run <- abs(arima.sim(n = 420, mean = 0.001, model = list(order = c(1, 0, 0), ar = 0.9))) + pace_min\n\nts.plot(ts_sim_classic_run, xlab = \"Distance [x100m]\", ylab = \"Differential pace [min/km]\", main = \"Example of classic run\", ylim = c(0, 25))\n\n# wall run\nts_sim_part1 <- abs(arima.sim(n = 210, model = list(order = c(1, 0, 0), ar = 0.9))) + pace_min\nts_sim_part2 <- ts(arima.sim(n = 210, model = list(order = c(1, 0, 0), ar = 0.9)) + pace_wall, start = 211, end = 420)\n\nts_sim_wall_run <- ts.union(ts_sim_part1, ts_sim_part2)\nts_sim_wall_run <- pmin(ts_sim_wall_run[, 1], ts_sim_wall_run[, 2], na.rm = TRUE)\n\nts.plot(ts_sim_wall_run, xlab = \"Distance [x100m]\", ylab = \"Differential pace [min/km]\", main = \"Example of wall run\", ylim = c(0, 25))\n```\n\n::: {.cell-output-display}\n![](timeseries-clustering-part1_files/figure-html/unnamed-chunk-3-1.png){width=384}\n:::\n\n::: {.cell-output-display}\n![](timeseries-clustering-part1_files/figure-html/unnamed-chunk-3-2.png){width=384}\n:::\n:::\n\n\n### Bootstrap\n\nWith our two base profiles created, we'll now bootstrap them. This process replicates the profiles with slight variations, giving us two groups with five time series each.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nts_sim_boot_classic <- ts_sim_classic_run %>%\n  tseries::tsbootstrap(., nb = 5, b = 200, type = \"block\") %>%\n  as.data.frame(.) %>%\n  dplyr::rename_all(funs(c(paste0(\"classic_\", .))))\n\nts_sim_boot_wall <- ts_sim_wall_run %>%\n  tseries::tsbootstrap(., nb = 5, b = 350, type = \"block\") %>%\n  as.data.frame(.) %>%\n  dplyr::rename_all(funs(c(paste0(\"wall_\", .))))\n\nts_sim_df <- cbind(ts_sim_boot_classic, ts_sim_boot_wall)\n```\n:::\n\n\n### Heatmap cluster\n\n{ggplot2} is fantastic, but for a quick and efficient heatmap, other packages are sometimes better. I'll use {gplots} here, as it can generate a heatmap with dendrograms using a single function. You can find a complete guide to R heatmaps [here](http://www.sthda.com/english/articles/28-hierarchical-clustering-essentials/93-heatmap-static-and-interactive-absolute-guide/).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndtw_dist <- function(x) {\n  dist(x, method = \"DTW\")\n}\n\nts_sim_df %>%\n  as.matrix() %>%\n  gplots::heatmap.2(\n    # dendrogram control\n    distfun = dtw_dist,\n    hclustfun = hclust,\n    dendrogram = \"column\",\n    Rowv = FALSE,\n    labRow = FALSE\n  )\n```\n\n::: {.cell-output-display}\n![](timeseries-clustering-part1_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nThe heatmap already shows a clear separation between the 'classic' and 'wall' runs. But since our focus is on DTW, let's move on to the {TSclust} and {dtwclust} packages.\n\n## DTW cluster\n\nThe workflow for both {TSclust} and {dtwclust} involves the same general steps:\n\n1. Compute a dissimilarity matrix for all time series pairs using a distance metric like DTW (as described by Montero & Vilar, 2014).\n2. Apply hierarchical clustering to the dissimilarity matrix.\n3. Generate a dendrogram to visualize the cluster results. The technique for plotting the time series next to the dendrogram comes from [Ian Hansel's blog](http://www.hanselsolutions.com/blog/clustering-time-series.html).\n\n### Using {TSclust}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# cluster analysis\ndist_ts <- TSclust::diss(SERIES = t(ts_sim_df), METHOD = \"DTWARP\") # note the dataframe must be transposed\nhc <- stats::hclust(dist_ts, method = \"complete\") # meathod can be also \"average\" or diana (for DIvisive ANAlysis Clustering)\n# k for cluster which is 2 in our case (classic vs. wall)\nhclus <- stats::cutree(hc, k = 2) %>% # hclus <- cluster::pam(dist_ts, k = 2)$clustering has a similar result\n  as.data.frame(.) %>%\n  dplyr::rename(., cluster_group = .) %>%\n  tibble::rownames_to_column(\"type_col\")\n\nhcdata <- ggdendro::dendro_data(hc)\nnames_order <- hcdata$labels$label\n# Use the folloing to remove labels from dendogram so not doubling up - but good for checking hcdata$labels$label <- \"\"\n\np1 <- hcdata %>%\n  ggdendro::ggdendrogram(., rotate = TRUE, leaf_labels = FALSE)\n\np2 <- ts_sim_df %>%\n  dplyr::mutate(index = 1:420) %>%\n  tidyr::gather(key = type_col, value = value, -index) %>%\n  dplyr::full_join(., hclus, by = \"type_col\") %>%\n  mutate(type_col = factor(type_col, levels = rev(as.character(names_order)))) %>%\n  ggplot(aes(x = index, y = value, colour = cluster_group)) +\n  geom_line() +\n  facet_wrap(~type_col, ncol = 1, strip.position = \"left\") +\n  guides(color = FALSE) +\n  theme_bw() +\n  theme(strip.background = element_blank(), strip.text = element_blank())\n\ngp1 <- ggplotGrob(p1)\ngp2 <- ggplotGrob(p2)\n\ngrid.arrange(gp2, gp1, ncol = 2, widths = c(4, 2))\n```\n\n::: {.cell-output-display}\n![](timeseries-clustering-part1_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n{TSclust} successfully separates the time series into two groups as expected. Looking closer, however, the 'wall' runs within their cluster aren't perfectly ordered by shape. Let's see if {dtwclust} performs better.\n\n### Using {dtwclust}\n\nThe standout feature of {dtwclust} is its high level of customization for the clustering process. The [package vignette](https://cran.r-project.org/web/packages/dtwclust/vignettes/dtwclust.pdf) provides a comprehensive look at all the available options.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncluster_dtw_h2 <- dtwclust::tsclust(t(ts_sim_df),\n  type = \"h\",\n  k = 2,\n  distance = \"dtw\",\n  control = hierarchical_control(method = \"complete\"),\n  preproc = NULL,\n  args = tsclust_args(dist = list(window.size = 5L))\n)\n\nhclus <- stats::cutree(cluster_dtw_h2, k = 2) %>% # hclus <- cluster::pam(dist_ts, k = 2)$clustering has a similar result\n  as.data.frame(.) %>%\n  dplyr::rename(., cluster_group = .) %>%\n  tibble::rownames_to_column(\"type_col\")\n\nhcdata <- ggdendro::dendro_data(cluster_dtw_h2)\nnames_order <- hcdata$labels$label\n# Use the folloing to remove labels from dendogram so not doubling up - but good for checking hcdata$labels$label <- \"\"\n\np1 <- hcdata %>%\n  ggdendro::ggdendrogram(., rotate = TRUE, leaf_labels = FALSE)\n\np2 <- ts_sim_df %>%\n  dplyr::mutate(index = 1:420) %>%\n  tidyr::gather(key = type_col, value = value, -index) %>%\n  dplyr::full_join(., hclus, by = \"type_col\") %>%\n  mutate(type_col = factor(type_col, levels = rev(as.character(names_order)))) %>%\n  ggplot(aes(x = index, y = value, colour = cluster_group)) +\n  geom_line() +\n  facet_wrap(~type_col, ncol = 1, strip.position = \"left\") +\n  guides(color = FALSE) +\n  theme_bw() +\n  theme(strip.background = element_blank(), strip.text = element_blank())\n\ngp1 <- ggplotGrob(p1)\ngp2 <- ggplotGrob(p2)\n\ngrid.arrange(gp2, gp1, ncol = 2, widths = c(4, 2))\n```\n\n::: {.cell-output-display}\n![](timeseries-clustering-part1_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nThis result is better. The clusters correctly separate the 'classic' and 'wall' runs, and now, time series with similar shapes are also grouped together within each cluster.\n\nWe can refine this further by modifying the arguments to cluster based on z-scores and calculate centroids using the built-in `shape_extraction()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncluster_dtw_h2 <- dtwclust::tsclust(t(ts_sim_df),\n  type = \"h\", k = 2L,\n  preproc = zscore,\n  distance = \"dtw\", centroid = shape_extraction,\n  control = hierarchical_control(method = \"complete\")\n)\n\nhclus <- stats::cutree(cluster_dtw_h2, k = 2) %>% # hclus <- cluster::pam(dist_ts, k = 2)$clustering has a similar result\n  as.data.frame(.) %>%\n  dplyr::rename(., cluster_group = .) %>%\n  tibble::rownames_to_column(\"type_col\")\n\nhcdata <- ggdendro::dendro_data(cluster_dtw_h2)\nnames_order <- hcdata$labels$label\n# Use the folloing to remove labels from dendogram so not doubling up - but good for checking hcdata$labels$label <- \"\"\n\np1 <- hcdata %>%\n  ggdendro::ggdendrogram(., rotate = TRUE, leaf_labels = FALSE)\n\np2 <- ts_sim_df %>%\n  dplyr::mutate(index = 1:420) %>%\n  tidyr::gather(key = type_col, value = value, -index) %>%\n  dplyr::full_join(., hclus, by = \"type_col\") %>%\n  mutate(type_col = factor(type_col, levels = rev(as.character(names_order)))) %>%\n  ggplot(aes(x = index, y = value, colour = cluster_group)) +\n  geom_line() +\n  facet_wrap(~type_col, ncol = 1, strip.position = \"left\") +\n  guides(color = FALSE) +\n  theme_bw() +\n  theme(strip.background = element_blank(), strip.text = element_blank())\n\ngp1 <- ggplotGrob(p1)\ngp2 <- ggplotGrob(p2)\n\ngrid.arrange(gp2, gp1, ncol = 2, widths = c(4, 2))\n```\n\n::: {.cell-output-display}\n![](timeseries-clustering-part1_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nAs shown in the vignette, we can also register a custom function for a normalized and asymmetric variant of DTW.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Normalized DTW\nndtw <- function(x, y, ...) {\n  dtw(x, y, ...,\n    step.pattern = asymmetric,\n    distance.only = TRUE\n  )$normalizedDistance\n}\n# Register the distance with proxy\nproxy::pr_DB$set_entry(\n  FUN = ndtw, names = c(\"nDTW\"),\n  loop = TRUE, type = \"metric\", distance = TRUE,\n  description = \"Normalized, asymmetric DTW\"\n)\n# Partitional clustering\ncluster_dtw_h2 <- dtwclust::tsclust(t(ts_sim_df), k = 2L, distance = \"nDTW\")\n\nplot(cluster_dtw_h2)\n```\n\n::: {.cell-output-display}\n![](timeseries-clustering-part1_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nWhile this partitional approach works well for the sine data, it's less accurate for our ARIMA-based simulations. A drawback of this method is that I can't extract a dendrogram from the `cluster_dtw_h2` object directly, but the distance matrix it contains could still be useful.\n\nThis initial analysis shows the promise of DTW. To continue this work, future steps would involve testing the method on time series with greater dissimilarities and, most importantly, applying it to a real-world dataset.\n",
    "supporting": [
      "timeseries-clustering-part1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}